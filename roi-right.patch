*** Begin Patch
*** Update File: boot_cycle_gui_web-macpc.py
@@
-# Live thumbnail target size (keep 16:9 to match source aspect)
+# Live thumbnail target size (keep 16:9 to match source aspect)
 THUMB_W = 256
 THUMB_H = 144
 
@@
-def crop(bgr, cw=CENTER_W):
-    h, w, _ = bgr.shape
-    # If cw is <= 0 or >= frame width, use the full frame (no side-gutter crop).
-    try:
-        if cw is None:
-            cw = CENTER_W
-        cw = int(cw)
-    except Exception:
-        cw = CENTER_W
-    if cw <= 0 or cw >= w:
-        gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
-        return cv2.resize(gray, (THUMB_W, THUMB_H))
-
-    s = (w - cw) // 2
-    if s <= 0:
-        gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
-        return cv2.resize(gray, (THUMB_W, THUMB_H))
-
-    g = cv2.cvtColor(np.concatenate([bgr[:, :s], bgr[:, w - s:]], 1), cv2.COLOR_BGR2GRAY)
-    return cv2.resize(g, (THUMB_W, THUMB_H))
+def crop(bgr, cw=CENTER_W, roi_mode="right", right_w=640):
+    """
+    Extracts the analysis region, then resizes to the fixed 16:9 thumbnail.
+    roi_mode:
+      - "full"   : full frame
+      - "gutters": concatenated left+right gutters (legacy center-width logic)
+      - "right"  : rightmost strip of width `right_w` pixels
+    """
+    h, w, _ = bgr.shape
+
+    # FULL
+    if str(roi_mode).lower() == "full":
+        gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
+        return cv2.resize(gray, (THUMB_W, THUMB_H))
+
+    # RIGHT STRIP
+    if str(roi_mode).lower() == "right":
+        try:
+            rw = int(right_w)
+        except Exception:
+            rw = 640
+        rw = max(1, min(rw, w))
+        roi = bgr[:, w - rw :]
+        gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
+        return cv2.resize(gray, (THUMB_W, THUMB_H))
+
+    # GUTTERS (legacy)
+    try:
+        if cw is None:
+            cw = CENTER_W
+        cw = int(cw)
+    except Exception:
+        cw = CENTER_W
+    if cw <= 0 or cw >= w:
+        gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
+        return cv2.resize(gray, (THUMB_W, THUMB_H))
+    s = (w - cw) // 2
+    if s <= 0:
+        gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
+        return cv2.resize(gray, (THUMB_W, THUMB_H))
+    g = cv2.cvtColor(np.concatenate([bgr[:, :s], bgr[:, w - s:]], 1), cv2.COLOR_BGR2GRAY)
+    return cv2.resize(g, (THUMB_W, THUMB_H))
@@
-def ph_ref(path, cw):
+def ph_ref(path, cw, roi_mode, right_w):
     img = cv2.imread(path)
     if img is None:
         raise RuntimeError(f"Failed to read reference image: {path} (cwd={os.getcwd()})")
-    return ph(crop(img, cw))
+    return ph(crop(img, cw, roi_mode=roi_mode, right_w=right_w))
@@
 class Monitor:
     def __init__(self):
@@
         self.margin    = MARGIN
         # live-crop thumbnail throttling
         self.thumb_every_ms = THUMB_EVERY_MS
         self.thumb_enabled  = True
         self._last_thumb_ts = 0.0
+        # ROI selection
+        self.roi_mode  = "right"   # "right" | "full" | "gutters"
+        self.right_w   = 640
         self.bars_ref  = BARS_REF
         self.int_ref   = INT_REF
         self.int_ref2  = INT_REF2
         self.csv_path  = CSV_PATH
@@
-        self.last_seen = {"BARS": None, "INTERFACE": None, "OTHER": None, "NO_SIGNAL": None}
+        self.last_seen = {"BARS": None, "INTERFACE": None, "OTHER": None, "NO_SIGNAL": None}
@@
-    def reset_counts_and_roll_csv(self):
+    def reset_counts_and_roll_csv(self):
@@
-    def reset_tallies(self):
+    def reset_tallies(self):
@@
-        self.last_seen = {"BARS": None, "INTERFACE": None, "OTHER": None, "NO_SIGNAL": None}
+        self.last_seen = {"BARS": None, "INTERFACE": None, "OTHER": None, "NO_SIGNAL": None}
         self.await_connect = True
@@
-def decide(frame, bars_h, int_h, center_w, thresh, dmean, dstd, int2_h=None):
-    cg = crop(frame, center_w)
+def decide(frame, bars_h, int_h, center_w, thresh, dmean, dstd, int2_h=None, roi_mode="right", right_w=640):
+    cg = crop(frame, center_w, roi_mode=roi_mode, right_w=right_w)
     phv = ph(cg)
@@
 def run_loop():
     mon.worker = threading.current_thread()
     try:
-        bars_h = ph_ref(mon.bars_ref, mon.center_w)
-        int_h  = ph_ref(mon.int_ref,  mon.center_w)
+        bars_h = ph_ref(mon.bars_ref, mon.center_w, mon.roi_mode, mon.right_w)
+        int_h  = ph_ref(mon.int_ref,  mon.center_w, mon.roi_mode, mon.right_w)
         int2_h = None
         try:
-            int2_h = ph_ref(mon.int_ref2, mon.center_w)
+            int2_h = ph_ref(mon.int_ref2, mon.center_w, mon.roi_mode, mon.right_w)
         except Exception:
             int2_h = None
     except Exception as e:
@@
-                cw, thr, st = mon.center_w, mon.thresh, mon.stable_frames
+                cw, thr, st = mon.center_w, mon.thresh, mon.stable_frames
                 dmean, dstd = mon.dark_mean, mon.dark_std
                 # get anti-flicker tunables from monitor instance
                 hold_ms = mon.hold_ms
                 margin  = mon.margin
+                roi_mode = mon.roi_mode
+                right_w  = mon.right_w
@@
-            det, db, di, crop_img, mean_l, std_l = decide(frame, bars_h, int_h, cw, thr, dmean, dstd, int2_h=int2_h)
+            det, db, di, crop_img, mean_l, std_l = decide(
+                frame, bars_h, int_h, cw, thr, dmean, dstd,
+                int2_h=int2_h, roi_mode=roi_mode, right_w=right_w
+            )
@@
-                    mon.last_crop = crop_img.copy()
+                    mon.last_crop = crop_img.copy()
                     mon._last_thumb_ts = now_sec
@@
 app = Flask(__name__)
@@
-      <div><label>Dark Std</label><input id="ds" type="number" value="{{ds}}"></div>
+      <div><label>Dark Std</label><input id="ds" type="number" value="{{ds}}"></div>
+      <div><label>ROI Mode</label>
+        <select id="roi">
+          <option value="right">Right strip</option>
+          <option value="full">Full frame</option>
+          <option value="gutters">Left+Right gutters</option>
+        </select>
+      </div>
+      <div><label>Right width (px)</label><input id="rw" type="number" value="640"></div>
       <div><label>Device Disconnected Ref</label><input id="bars" value="{{bars}}"></div>
       <div><label>Scope Connected Ref</label><input id="intr" value="{{intr}}"></div>
       <div><label>Scope Connected (Alt) Ref</label><input id="intr2" value="{{intr2}}"></div>
       <div><label>CSV Path</label><input id="csv" value="{{csv}}"></div>
@@
     let backendInit = false;
     let fourccInit = false;
     let resInit = false;
+    let roiInit = false;
@@
       if (!resInit) {
         document.getElementById('res').value = (j.res_preset || '1080p');
         resInit = true;
       }
+      if (!roiInit) {
+        document.getElementById('roi').value = (j.roi_mode || 'right');
+        document.getElementById('rw').value  = (j.right_w  || 640);
+        roiInit = true;
+      }
@@
       const body = {
         src:  document.getElementById('src').value,
         backend: document.getElementById('backend').value,
         fourcc: document.getElementById('fourcc').value,
         res:    document.getElementById('res').value,
         stream: document.getElementById('stream').value,
         cw:   parseInt(document.getElementById('cw').value),
         thr:  parseInt(document.getElementById('thr').value),
         st:   parseInt(document.getElementById('st').value),
         dm:   parseFloat(document.getElementById('dm').value),
         ds:   parseFloat(document.getElementById('ds').value),
+        roi:  document.getElementById('roi').value,
+        rw:   parseInt(document.getElementById('rw').value),
         bars: document.getElementById('bars').value,
         intr: document.getElementById('intr').value,
         intr2: document.getElementById('intr2').value,
         csv:  document.getElementById('csv').value,
       };
@@
 def index():
     return render_template_string(HTML,
         src=mon.src, cw=mon.center_w, thr=mon.thresh, st=mon.stable_frames,
-        dm=mon.dark_mean, ds=mon.dark_std, bars=mon.bars_ref, intr=mon.int_ref, intr2=mon.int_ref2,
+        dm=mon.dark_mean, ds=mon.dark_std, bars=mon.bars_ref, intr=mon.int_ref, intr2=mon.int_ref2,
         csv=mon.csv_path, stream=mon.stream_path, backend=mon.backend_name,
-        fourcc=mon.fourcc, res=mon.res_preset
+        fourcc=mon.fourcc, res=mon.res_preset
     )
@@
 def status():
     with mon.lock:
         sf = label_for(mon.status) if mon.status in ("BARS","INTERFACE","OTHER","NO_SIGNAL") else mon.status
         return jsonify(
             status=mon.status, status_friendly=sf, running=mon.running,
             count_bars=mon.count_bars, count_int=mon.count_int,
             count_other=mon.count_other, cycles=mon.cycles,
             last_seen=mon.last_seen, backend=mon.backend_name,
-            fourcc=mon.fourcc, res_preset=mon.res_preset
+            fourcc=mon.fourcc, res_preset=mon.res_preset,
+            roi_mode=mon.roi_mode, right_w=mon.right_w
         )
@@
 def thumb():
     with mon.lock:
         img = mon.last_crop
         if img is None and mon.last_frame is not None:
             # Build a one-off crop so the UI still has something to show
             try:
-                img = crop(mon.last_frame, mon.center_w)
+                img = crop(mon.last_frame, mon.center_w, roi_mode=mon.roi_mode, right_w=mon.right_w)
             except Exception:
                 img = None
         if img is None:
             # Serve a neutral placeholder instead of 404 to keep the UI clean
             img = _placeholder_thumb()
@@
 def peek():
@@
-        backend_name = mon.backend_name
+        backend_name = mon.backend_name
+        roi_mode = mon.roi_mode
+        right_w  = mon.right_w
@@
-        bars_h = ph_ref(bars_path, cw)
-        int_h  = ph_ref(int_path,  cw)
+        bars_h = ph_ref(bars_path, cw, roi_mode, right_w)
+        int_h  = ph_ref(int_path,  cw, roi_mode, right_w)
         int2_h = None
         try:
-            int2_h = ph_ref(mon.int_ref2, cw)
+            int2_h = ph_ref(mon.int_ref2, cw, roi_mode, right_w)
         except Exception:
             int2_h = None
@@
-        det, db, di, crop_img, mean_l, std_l = decide(frame, bars_h, int_h, cw, thr, dmean, dstd, int2_h=int2_h)
+        det, db, di, crop_img, mean_l, std_l = decide(
+            frame, bars_h, int_h, cw, thr, dmean, dstd,
+            int2_h=int2_h, roi_mode=roi_mode, right_w=right_w
+        )
         return jsonify(db=int(db), di=int(di), mean=round(float(mean_l),2), std=round(float(std_l),2), det=det)
@@
 def start():
     cfg = request.get_json(force=True)
     cfg_copy = dict(cfg) if isinstance(cfg, dict) else {}
     with mon.lock:
         if mon.running:
             return jsonify(ok=True, already=True)
         mon.last_cfg = cfg_copy
@@
         mon.dark_std  = float(cfg.get("ds", mon.dark_std))
+        mon.roi_mode  = str(cfg.get("roi", mon.roi_mode)).lower()
+        try:
+            mon.right_w = int(cfg.get("rw", mon.right_w))
+        except Exception:
+            mon.right_w = mon.right_w
         mon.bars_ref  = cfg.get("bars", mon.bars_ref)
         mon.int_ref   = cfg.get("intr", mon.int_ref)
         mon.int_ref2  = cfg.get("intr2", mon.int_ref2)
         mon.csv_path  = cfg.get("csv", mon.csv_path)
*** End Patch